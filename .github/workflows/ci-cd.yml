# ===================================
# GitHub Actions CI/CD - CORRÉGÉ POUR ESGI
# E-commerce Microservices Docker
# ===================================

name: 🚀 CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  PROJECT_NAME: savita2618/e-commerce-vue
  GITHUB_REPOSITORY: savita2618/e-commerce-vue

jobs:
  # ===================================
  # 1. VALIDATION
  # ===================================
  validate:
    name: 🔍 Validation
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      image_tag: ${{ steps.vars.outputs.image_tag }}
      registry_image: ${{ steps.vars.outputs.registry_image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Set variables
        id: vars
        run: |
          echo "image_tag=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "registry_image=${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}" >> $GITHUB_OUTPUT
          
      - name: Check if should build
        id: check
        run: |
          echo "should_build=true" >> $GITHUB_OUTPUT
          
      - name: Validate structure
        run: |
          echo "🔍 Validation de la structure..."
          
          # Vérifier services backend
          for service in auth-service product-service order-service; do
            if [ -f "services/$service/Dockerfile" ]; then
              echo "✅ services/$service/Dockerfile found"
            else
              echo "❌ services/$service/Dockerfile missing"
              exit 1
            fi
            
            if [ -f "services/$service/package.json" ]; then
              echo "✅ services/$service/package.json found"
            else
              echo "❌ services/$service/package.json missing"
              exit 1
            fi
          done
          
          # Vérifier frontend
          if [ -f "frontend/Dockerfile" ]; then
            echo "✅ frontend/Dockerfile found"
          else
            echo "❌ frontend/Dockerfile missing"
            exit 1
          fi
          
          echo "✅ Structure validée"

  # ===================================
  # 2. BUILD IMAGES
  # ===================================
  build:
    name: 🏗️ Build
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should_build == 'true'
    strategy:
      matrix:
        service: [auth-service, product-service, order-service, frontend]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Determine build context
        id: context
        run: |
          if [ "${{ matrix.service }}" = "frontend" ]; then
            echo "context=./frontend" >> $GITHUB_OUTPUT
            echo "dockerfile=./frontend/Dockerfile" >> $GITHUB_OUTPUT
          else
            echo "context=./services/${{ matrix.service }}" >> $GITHUB_OUTPUT
            echo "dockerfile=./services/${{ matrix.service }}/Dockerfile" >> $GITHUB_OUTPUT
          fi
          
      - name: Build and push ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.context.outputs.context }}
          file: ${{ steps.context.outputs.dockerfile }}
          target: development
          push: true
          tags: |
            ${{ needs.validate.outputs.registry_image }}/${{ matrix.service }}:${{ needs.validate.outputs.image_tag }}
            ${{ needs.validate.outputs.registry_image }}/${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=development
            VITE_AUTH_SERVICE_URL=${{ secrets.VITE_AUTH_SERVICE_URL }}
            VITE_PRODUCT_SERVICE_URL=${{ secrets.VITE_PRODUCT_SERVICE_URL }}
            VITE_ORDER_SERVICE_URL=${{ secrets.VITE_ORDER_SERVICE_URL }}

  # ===================================
  # 3. TESTS INTÉGRATION
  # ===================================
  test:
    name: 🧪 Tests d'Intégration
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: needs.validate.outputs.should_build == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Create docker-compose.test.yml
        run: |
          echo "📝 Création du fichier docker-compose.test.yml..."
          
          # Utiliser les secrets GitHub et créer le docker-compose dynamiquement
          cat > docker-compose.test.yml << EOF
          version: '3.8'

          services:
            # ===================================
            # BASES DE DONNÉES MONGODB
            # ===================================
            mongodb-auth-test:
              image: mongo:4.4
              container_name: mongodb-auth-test
              environment:
                MONGO_INITDB_ROOT_USERNAME: ${{ secrets.MONGO_ROOT_USERNAME }}
                MONGO_INITDB_ROOT_PASSWORD: ${{ secrets.MONGO_ROOT_PASSWORD }}
                MONGO_INITDB_DATABASE: authdb_test
              networks:
                - test-network
              healthcheck:
                test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
                interval: 10s
                timeout: 5s
                retries: 10
                start_period: 30s
                
            mongodb-products-test:
              image: mongo:4.4
              container_name: mongodb-products-test
              environment:
                MONGO_INITDB_ROOT_USERNAME: ${{ secrets.MONGO_ROOT_USERNAME }}
                MONGO_INITDB_ROOT_PASSWORD: ${{ secrets.MONGO_ROOT_PASSWORD }}
                MONGO_INITDB_DATABASE: productsdb_test
              networks:
                - test-network
              healthcheck:
                test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
                interval: 10s
                timeout: 5s
                retries: 10
                start_period: 30s
                
            mongodb-orders-test:
              image: mongo:4.4
              container_name: mongodb-orders-test
              environment:
                MONGO_INITDB_ROOT_USERNAME: ${{ secrets.MONGO_ROOT_USERNAME }}
                MONGO_INITDB_ROOT_PASSWORD: ${{ secrets.MONGO_ROOT_PASSWORD }}
                MONGO_INITDB_DATABASE: ordersdb_test
              networks:
                - test-network
              healthcheck:
                test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
                interval: 10s
                timeout: 5s
                retries: 10
                start_period: 30s

            # ===================================
            # SERVICES BACKEND
            # ===================================
            auth-service:
              image: ${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}/auth-service:${{ needs.validate.outputs.image_tag }}
              container_name: auth-service-test
              environment:
                NODE_ENV: test
                PORT: 3001
                MONGODB_URI: mongodb://${{ secrets.MONGO_ROOT_USERNAME }}:${{ secrets.MONGO_ROOT_PASSWORD }}@mongodb-auth-test:27017/authdb_test?authSource=admin
                JWT_SECRET: ${{ secrets.JWT_SECRET }}
              ports:
                - "3001:3001"
              networks:
                - test-network
              depends_on:
                mongodb-auth-test:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3001/api/health"]
                interval: 15s
                timeout: 10s
                retries: 5
                start_period: 45s

            product-service:
              image: ${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}/product-service:${{ needs.validate.outputs.image_tag }}
              container_name: product-service-test
              environment:
                NODE_ENV: test
                PORT: 3000
                MONGODB_URI: mongodb://${{ secrets.MONGO_ROOT_USERNAME }}:${{ secrets.MONGO_ROOT_PASSWORD }}@mongodb-products-test:27017/productsdb_test?authSource=admin
                JWT_SECRET: ${{ secrets.JWT_SECRET }}
              ports:
                - "3000:3000"
              networks:
                - test-network
              depends_on:
                mongodb-products-test:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
                interval: 15s
                timeout: 10s
                retries: 5
                start_period: 45s

            order-service:
              image: ${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}/order-service:${{ needs.validate.outputs.image_tag }}
              container_name: order-service-test
              environment:
                NODE_ENV: test
                PORT: 3002
                MONGODB_URI: mongodb://${{ secrets.MONGO_ROOT_USERNAME }}:${{ secrets.MONGO_ROOT_PASSWORD }}@mongodb-orders-test:27017/ordersdb_test?authSource=admin
                JWT_SECRET: ${{ secrets.JWT_SECRET }}
                VITE_PRODUCT_SERVICE_URL: http://product-service:3000
              ports:
                - "3002:3002"
              networks:
                - test-network
              depends_on:
                mongodb-orders-test:
                  condition: service_healthy
                product-service:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3002/api/health"]
                interval: 15s
                timeout: 10s
                retries: 5
                start_period: 45s

            # ===================================
            # FRONTEND
            # ===================================
            frontend:
              image: ${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}/frontend:${{ needs.validate.outputs.image_tag }}
              container_name: frontend-test
              environment:
                NODE_ENV: test
                VITE_AUTH_SERVICE_URL: ${{ secrets.VITE_AUTH_SERVICE_URL }}
                VITE_PRODUCT_SERVICE_URL: ${{ secrets.VITE_PRODUCT_SERVICE_URL }}
                VITE_ORDER_SERVICE_URL: ${{ secrets.VITE_ORDER_SERVICE_URL }}
              ports:
                - "8080:8080"
              networks:
                - test-network
              depends_on:
                auth-service:
                  condition: service_healthy
                product-service:
                  condition: service_healthy
                order-service:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080"]
                interval: 15s
                timeout: 10s
                retries: 5
                start_period: 30s

          networks:
            test-network:
              driver: bridge
              ipam:
                config:
                  - subnet: 172.21.0.0/16
          EOF
          
          echo "📋 docker-compose.test.yml créé avec les secrets GitHub"
          
      - name: Start services
        run: |
          echo "🚀 Démarrage des services de test..."
          
          # Démarrer les services
          docker compose -f docker-compose.test.yml up -d
          
          echo "⏳ Attente du démarrage des services..."
          sleep 60
          
          echo "📊 État des conteneurs:"
          docker compose -f docker-compose.test.yml ps
          
      - name: Wait for services
        run: |
          echo "⏳ Attente de la disponibilité des services..."
          
          # Fonction d'attente
          wait_for_service() {
            local service_name=$1
            local port=$2
            local max_attempts=30
            local attempt=1
            
            echo "Attente de $service_name sur le port $port..."
            while [ $attempt -le $max_attempts ]; do
              if curl -f http://localhost:$port/api/health >/dev/null 2>&1; then
                echo "✅ $service_name prêt (tentative $attempt)"
                return 0
              fi
              echo "⏳ $service_name - tentative $attempt/$max_attempts"
              sleep 10
              ((attempt++))
            done
            
            echo "❌ $service_name - timeout après $max_attempts tentatives"
            return 1
          }
          
          # Attendre chaque service
          wait_for_service "auth-service" 3001 || true
          wait_for_service "product-service" 3000 || true
          wait_for_service "order-service" 3002 || true
          
          # Attendre le frontend
          echo "Attente du frontend..."
          if curl -f http://localhost:8080 >/dev/null 2>&1; then
            echo "✅ frontend prêt"
          else
            echo "⚠️ frontend pas complètement prêt"
          fi
          
      - name: Run health checks
        run: |
          echo "🏥 Vérification de l'état des services..."
          
          echo "📊 Résumé des tests:"
          echo "  - Auth service: $(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/api/health || echo "ERROR")"
          echo "  - Product service: $(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health || echo "ERROR")"
          echo "  - Order service: $(curl -s -o /dev/null -w "%{http_code}" http://localhost:3002/api/health || echo "ERROR")"
          echo "  - Frontend: $(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 || echo "ERROR")"
          
      - name: Show logs on failure
        if: failure()
        run: |
          echo "📋 Logs des services en cas d'échec..."
          echo "🔍 État des conteneurs:"
          docker compose -f docker-compose.test.yml ps
          echo ""
          echo "🔍 Logs auth-service:"
          docker compose -f docker-compose.test.yml logs auth-service || true
          echo ""
          echo "🔍 Logs product-service:"
          docker compose -f docker-compose.test.yml logs product-service || true
          echo ""
          echo "🔍 Logs order-service:"
          docker compose -f docker-compose.test.yml logs order-service || true
          echo ""
          echo "🔍 Logs frontend:"
          docker compose -f docker-compose.test.yml logs frontend || true
          echo ""
          echo "🔍 Logs MongoDB Auth:"
          docker compose -f docker-compose.test.yml logs mongodb-auth-test || true
          
      - name: Cleanup
        if: always()
        run: |
          echo "🧹 Nettoyage des ressources de test..."
          docker compose -f docker-compose.test.yml down -v --remove-orphans || true
          docker system prune -f || true
          echo "✅ Nettoyage terminé"

  # ===================================
  # 4. DEPLOY (uniquement sur main)
  # ===================================
  deploy:
    name: 🚀 Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, build, test]
    if: github.ref == 'refs/heads/main' && needs.validate.outputs.should_build == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Deploy notification
        run: |
          echo "🚀 Déploiement en production"
          echo "📦 Image tag: ${{ needs.validate.outputs.image_tag }}"
          echo "🏷️ Registry: ${{ needs.validate.outputs.registry_image }}"
          
          # Ici tu peux ajouter le déploiement réel vers ton serveur
          # Par exemple avec SSH, Docker Swarm, etc.