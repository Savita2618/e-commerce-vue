# ===================================
# GitHub Actions CI/CD Pipeline - ESGI Project
# E-commerce Microservices - Version Corrigée
# ===================================

name: 🚀 CI/CD E-commerce

on:
  push:
    branches: [ main, develop, feature/* ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      deploy_env:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  PROJECT_NAME: savita2618/e-commerce-vue
  # 🔐 Secrets depuis GitHub
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  MONGO_ROOT_USERNAME: ${{ secrets.MONGO_ROOT_USERNAME }}
  MONGO_ROOT_PASSWORD: ${{ secrets.MONGO_ROOT_PASSWORD }}
  # 🌐 Frontend URLs
  VITE_AUTH_SERVICE_URL: ${{ secrets.VITE_AUTH_SERVICE_URL }}
  VITE_PRODUCT_SERVICE_URL: ${{ secrets.VITE_PRODUCT_SERVICE_URL }}
  VITE_ORDER_SERVICE_URL: ${{ secrets.VITE_ORDER_SERVICE_URL }}

jobs:
  # ===================================
  # 1. VALIDATION RAPIDE
  # ===================================
  validate:
    name: 🔍 Validation
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      image_tag: ${{ steps.vars.outputs.image_tag }}
      registry_image: ${{ steps.vars.outputs.registry_image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Set variables
        id: vars
        run: |
          echo "image_tag=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "registry_image=${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}" >> $GITHUB_OUTPUT
          echo "jwt_secret=${{ env.JWT_SECRET }}" >> $GITHUB_OUTPUT
          
      - name: Check if should build
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] || \
             [[ "${{ github.ref }}" == "refs/heads/main" ]] || \
             [[ "${{ github.ref }}" == "refs/heads/develop" ]] || \
             [[ "${{ github.ref }}" == refs/heads/feature/* ]]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Validate structure
        run: |
          echo "🔍 Validation de la structure..."
          
          # Vérifier fichiers essentiels
          test -f docker-compose.yml && echo "✅ docker-compose.yml" || exit 1
          test -f .env && echo "✅ .env" || echo "⚠️ .env optionnel"
          
          # Vérifier services
          for service in auth-service product-service order-service; do
            test -f services/$service/Dockerfile && echo "✅ $service/Dockerfile" || exit 1
            test -f services/$service/package.json && echo "✅ $service/package.json" || exit 1
          done
          
          # Vérifier frontend
          test -f frontend/Dockerfile && echo "✅ frontend/Dockerfile" || exit 1
          test -f frontend/package.json && echo "✅ frontend/package.json" || exit 1
          
          echo "✅ Structure validée"

  # ===================================
  # 2. BUILD IMAGES EN PARALLÈLE
  # ===================================
  build:
    name: 🏗️ Build
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should_build == 'true'
    strategy:
      matrix:
        service: [auth-service, product-service, order-service, frontend]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Determine build context
        id: context
        run: |
          if [ "${{ matrix.service }}" = "frontend" ]; then
            echo "context=./frontend" >> $GITHUB_OUTPUT
            echo "dockerfile=./frontend/Dockerfile" >> $GITHUB_OUTPUT
          else
            echo "context=./services/${{ matrix.service }}" >> $GITHUB_OUTPUT
            echo "dockerfile=./services/${{ matrix.service }}/Dockerfile" >> $GITHUB_OUTPUT
          fi
          
      - name: Build and push ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.context.outputs.context }}
          file: ${{ steps.context.outputs.dockerfile }}
          target: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
          push: true
          tags: |
            ${{ needs.validate.outputs.registry_image }}/${{ matrix.service }}:${{ needs.validate.outputs.image_tag }}
            ${{ needs.validate.outputs.registry_image }}/${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
            VITE_AUTH_SERVICE_URL=${{ env.VITE_AUTH_SERVICE_URL }}
            VITE_PRODUCT_SERVICE_URL=${{ env.VITE_PRODUCT_SERVICE_URL }}
            VITE_ORDER_SERVICE_URL=${{ env.VITE_ORDER_SERVICE_URL }}

  # ===================================
  # 3. TESTS UNITAIRES
  # ===================================
  test:
    name: 🧪 Tests
    runs-on: ubuntu-latest
    needs: validate
    strategy:
      matrix:
        service: [auth-service, product-service, order-service, frontend]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            services/*/package-lock.json
            frontend/package-lock.json
            
      - name: Test ${{ matrix.service }}
        run: |
          if [ "${{ matrix.service }}" = "frontend" ]; then
            WORKDIR="./frontend"
          else
            WORKDIR="./services/${{ matrix.service }}"
          fi
          
          echo "🧪 Testing ${{ matrix.service }} dans $WORKDIR"
          cd $WORKDIR
          
          if [ -f package.json ]; then
            echo "Installing dependencies..."
            npm ci --prefer-offline --no-audit
            
            echo "Running linter..."
            npm run lint 2>/dev/null || echo "⚠️ Pas de linter configuré"
            
            echo "Running tests..."
            npm test 2>/dev/null || echo "⚠️ Pas de tests configurés"
            
            echo "✅ ${{ matrix.service }} testé"
          else
            echo "❌ package.json introuvable"
            exit 1
          fi

  # ===================================
  # 4. TESTS D'INTÉGRATION
  # ===================================
  integration:
    name: 🔄 Tests d'Intégration
    runs-on: ubuntu-latest
    needs: [validate, build, test]
    if: needs.validate.outputs.should_build == 'true'
    services:
      # Bases de données pour les tests
      mongodb-auth:
        image: mongo:4.4
        env:
          MONGO_INITDB_ROOT_USERNAME: ${{ env.MONGO_ROOT_USERNAME }}
          MONGO_INITDB_ROOT_PASSWORD: ${{ env.MONGO_ROOT_PASSWORD }}
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongo --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          
      mongodb-products:
        image: mongo:4.4
        env:
          MONGO_INITDB_ROOT_USERNAME: ${{ env.MONGO_ROOT_USERNAME }}
          MONGO_INITDB_ROOT_PASSWORD: ${{ env.MONGO_ROOT_PASSWORD }}
        ports:
          - 27018:27017
        options: >-
          --health-cmd "mongo --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          
      mongodb-orders:
        image: mongo:4.4
        env:
          MONGO_INITDB_ROOT_USERNAME: ${{ env.MONGO_ROOT_USERNAME }}
          MONGO_INITDB_ROOT_PASSWORD: ${{ env.MONGO_ROOT_PASSWORD }}
        ports:
          - 27019:27017
        options: >-
          --health-cmd "mongo --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Create test environment file
        run: |
          cat > .env.test << EOF
          NODE_ENV=test
          JWT_SECRET=${{ env.JWT_SECRET }}
          MONGO_ROOT_USERNAME=${{ env.MONGO_ROOT_USERNAME }}
          MONGO_ROOT_PASSWORD=${{ env.MONGO_ROOT_PASSWORD }}
          MONGODB_URI_AUTH=mongodb://${{ env.MONGO_ROOT_USERNAME }}:${{ env.MONGO_ROOT_PASSWORD }}@localhost:27017/authdb_test?authSource=admin
          MONGODB_URI_PRODUCTS=mongodb://${{ env.MONGO_ROOT_USERNAME }}:${{ env.MONGO_ROOT_PASSWORD }}@localhost:27018/productsdb_test?authSource=admin
          MONGODB_URI_ORDERS=mongodb://${{ env.MONGO_ROOT_USERNAME }}:${{ env.MONGO_ROOT_PASSWORD }}@localhost:27019/ordersdb_test?authSource=admin
          AUTH_SERVICE_URL=http://localhost:3001
          PRODUCT_SERVICE_URL=http://localhost:3000
          ORDER_SERVICE_URL=http://localhost:3002
          VITE_AUTH_SERVICE_URL=${{ env.VITE_AUTH_SERVICE_URL }}
          VITE_PRODUCT_SERVICE_URL=${{ env.VITE_PRODUCT_SERVICE_URL }}
          VITE_ORDER_SERVICE_URL=${{ env.VITE_ORDER_SERVICE_URL }}
          EOF
          
      - name: Start services for integration tests
        run: |
          echo "🚀 Démarrage des services pour les tests..."
          
          # Créer un docker-compose.test.yml temporaire
          cat > docker-compose.test.yml << EOF
          version: '3.8'
          services:
            auth-service:
              image: ${{ needs.validate.outputs.registry_image }}/auth-service:${{ needs.validate.outputs.image_tag }}
              environment:
                NODE_ENV: test
                PORT: 3001
                MONGODB_URI: mongodb://${{ env.MONGO_ROOT_USERNAME }}:${{ env.MONGO_ROOT_PASSWORD }}@host.docker.internal:27017/authdb_test?authSource=admin
                JWT_SECRET: ${{ env.JWT_SECRET }}
              ports:
                - "3001:3001"
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD-SHELL", "curl -f http://localhost:3001/api/health || exit 1"]
                interval: 10s
                timeout: 5s
                retries: 10
                start_period: 30s
                
            product-service:
              image: ${{ needs.validate.outputs.registry_image }}/product-service:${{ needs.validate.outputs.image_tag }}
              environment:
                NODE_ENV: test
                PORT: 3000
                MONGODB_URI: mongodb://${{ env.MONGO_ROOT_USERNAME }}:${{ env.MONGO_ROOT_PASSWORD }}@host.docker.internal:27018/productsdb_test?authSource=admin
                JWT_SECRET: ${{ env.JWT_SECRET }}
              ports:
                - "3000:3000"
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD-SHELL", "curl -f http://localhost:3000/api/health || exit 1"]
                interval: 10s
                timeout: 5s
                retries: 10
                start_period: 30s
                
            order-service:
              image: ${{ needs.validate.outputs.registry_image }}/order-service:${{ needs.validate.outputs.image_tag }}
              environment:
                NODE_ENV: test
                PORT: 3002
                MONGODB_URI: mongodb://${{ env.MONGO_ROOT_USERNAME }}:${{ env.MONGO_ROOT_PASSWORD }}@host.docker.internal:27019/ordersdb_test?authSource=admin
                JWT_SECRET: ${{ env.JWT_SECRET }}
                PRODUCT_SERVICE_URL: http://product-service:3000
              ports:
                - "3002:3002"
              depends_on:
                - product-service
              extra_hosts:
                - "host.docker.internal:host-gateway"
              healthcheck:
                test: ["CMD-SHELL", "curl -f http://localhost:3002/api/health || exit 1"]
                interval: 10s
                timeout: 5s
                retries: 10
                start_period: 30s
                
            frontend:
              image: ${{ needs.validate.outputs.registry_image }}/frontend:${{ needs.validate.outputs.image_tag }}
              environment:
                NODE_ENV: test
                VITE_AUTH_SERVICE_URL: ${{ env.VITE_AUTH_SERVICE_URL }}
                VITE_PRODUCT_SERVICE_URL: ${{ env.VITE_PRODUCT_SERVICE_URL }}
                VITE_ORDER_SERVICE_URL: ${{ env.VITE_ORDER_SERVICE_URL }}
              ports:
                - "8080:8080"
              depends_on:
                - auth-service
                - product-service
                - order-service
              healthcheck:
                test: ["CMD-SHELL", "curl -f http://localhost:8080 || exit 1"]
                interval: 10s
                timeout: 5s
                retries: 10
                start_period: 20s
          EOF
          
          # Démarrer les services avec docker compose (nouvelle syntaxe)
          docker compose -f docker-compose.test.yml up -d
          
      - name: Wait for services
        run: |
          echo "⏳ Attente de la disponibilité des services..."
          
          # Fonction d'attente
          wait_for_service() {
            local service_name=$1
            local port=$2
            local max_attempts=30
            local attempt=1
            
            echo "Attente de $service_name sur le port $port..."
            while [ $attempt -le $max_attempts ]; do
              if curl -f http://localhost:$port/api/health >/dev/null 2>&1; then
                echo "✅ $service_name prêt (tentative $attempt)"
                return 0
              fi
              echo "⏳ $service_name - tentative $attempt/$max_attempts"
              sleep 10
              ((attempt++))
            done
            
            echo "❌ $service_name - timeout après $max_attempts tentatives"
            return 1
          }
          
          # Attendre chaque service
          wait_for_service "auth-service" 3001
          wait_for_service "product-service" 3000
          wait_for_service "order-service" 3002
          
          # Attendre le frontend
          echo "Attente du frontend..."
          attempt=1
          max_attempts=20
          while [ $attempt -le $max_attempts ]; do
            if curl -f http://localhost:8080 >/dev/null 2>&1; then
              echo "✅ frontend prêt (tentative $attempt)"
              break
            fi
            echo "⏳ frontend - tentative $attempt/$max_attempts"
            sleep 5
            ((attempt++))
          done
          
          echo "🎉 Tous les services sont prêts pour les tests !"
          
      - name: Run integration tests
        run: |
          echo "🧪 Exécution des tests d'intégration..."
          
          # Test 1: Vérifier que tous les services répondent
          echo "📋 Test 1: Endpoints de santé"
          curl -f http://localhost:3001/api/health && echo "✅ Auth service health OK"
          curl -f http://localhost:3000/api/health && echo "✅ Product service health OK"
          curl -f http://localhost:3002/api/health && echo "✅ Order service health OK"
          curl -f http://localhost:8080 && echo "✅ Frontend OK"
          
          # Test 2: Test d'inscription utilisateur
          echo "📋 Test 2: Inscription utilisateur"
          response=$(curl -s -w "%{http_code}" -X POST http://localhost:3001/api/auth/register \
            -H "Content-Type: application/json" \
            -d '{"email":"test@esgi.fr","password":"password123","name":"Test User ESGI"}' \
            -o /tmp/register_response.json)
          
          if [ "$response" == "200" ] || [ "$response" == "201" ]; then
            echo "✅ Inscription réussie (code: $response)"
            cat /tmp/register_response.json
          else
            echo "⚠️ Inscription échouée (code: $response) - peut être normal si utilisateur existe"
          fi
          
          # Test 3: Test de connexion
          echo "📋 Test 3: Connexion utilisateur"
          response=$(curl -s -w "%{http_code}" -X POST http://localhost:3001/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email":"test@esgi.fr","password":"password123"}' \
            -o /tmp/login_response.json)
          
          if [ "$response" == "200" ]; then
            echo "✅ Connexion réussie"
            TOKEN=$(cat /tmp/login_response.json | jq -r '.token' 2>/dev/null || echo "")
            echo "Token obtenu: ${TOKEN:0:20}..."
          else
            echo "⚠️ Connexion échouée (code: $response)"
          fi
          
          # Test 4: Test des produits
          echo "📋 Test 4: Récupération des produits"
          response=$(curl -s -w "%{http_code}" http://localhost:3000/api/products -o /tmp/products_response.json)
          if [ "$response" == "200" ]; then
            echo "✅ Produits récupérés"
            echo "Nombre de produits: $(cat /tmp/products_response.json | jq length 2>/dev/null || echo 'N/A')"
          else
            echo "❌ Échec récupération produits (code: $response)"
          fi
          
          # Test 5: Test frontend
          echo "📋 Test 5: Frontend accessible"
          if curl -s http://localhost:8080 | grep -q "<!DOCTYPE html>"; then
            echo "✅ Frontend sert du HTML"
          else
            echo "⚠️ Frontend ne sert pas de HTML valide"
          fi
          
          echo "🎉 Tests d'intégration terminés !"
          
      - name: Show logs on failure
        if: failure()
        run: |
          echo "📋 Logs des services en cas d'échec..."
          docker compose -f docker-compose.test.yml logs auth-service || true
          docker compose -f docker-compose.test.yml logs product-service || true
          docker compose -f docker-compose.test.yml logs order-service || true
          docker compose -f docker-compose.test.yml logs frontend || true
          
      - name: Cleanup
        if: always()
        run: |
          docker compose -f docker-compose.test.yml down -v --remove-orphans || true

  # ===================================
  # 5. DÉPLOIEMENT
  # ===================================
  deploy:
    name: 🚀 Deploy
    runs-on: ubuntu-latest
    needs: [validate, build, integration]
    if: |
      always() && 
      needs.integration.result == 'success' && 
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Determine deployment environment
        id: env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ inputs.deploy_env }}" == "production" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "compose_file=docker-compose.prod.yml" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "compose_file=docker-compose.yml" >> $GITHUB_OUTPUT
          fi
          
      - name: Deploy to ${{ steps.env.outputs.environment }}
        run: |
          echo "🚀 Déploiement vers ${{ steps.env.outputs.environment }}..."
          echo "Branch: ${{ github.ref }}"
          echo "Image tag: ${{ needs.validate.outputs.image_tag }}"
          echo "Registry: ${{ needs.validate.outputs.registry_image }}"
          echo "Compose file: ${{ steps.env.outputs.compose_file }}"
          
          # Ici tu peux ajouter tes commandes de déploiement réelles
          # Par exemple, SSH vers ton serveur, mise à jour des images, etc.
          
          echo "✅ Déploiement ${{ steps.env.outputs.environment }} terminé !"

  # ===================================
  # 6. NOTIFICATION ET RÉSUMÉ
  # ===================================
  notify:
    name: 📊 Résumé
    runs-on: ubuntu-latest
    needs: [validate, build, test, integration, deploy]
    if: always()
    steps:
      - name: Pipeline summary
        run: |
          echo "🎯 RÉSUMÉ DU PIPELINE CI/CD"
          echo "=================================="
          echo "Branch: ${{ github.ref }}"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.event_name }}"
          echo ""
          echo "📊 RÉSULTATS:"
          echo "✅ Validation: ${{ needs.validate.result }}"
          echo "✅ Build: ${{ needs.build.result }}"
          echo "✅ Tests: ${{ needs.test.result }}"
          echo "✅ Intégration: ${{ needs.integration.result }}"
          echo "✅ Déploiement: ${{ needs.deploy.result }}"
          echo ""
          
          if [ "${{ needs.integration.result }}" == "success" ]; then
            echo "🎉 PIPELINE RÉUSSIE ! Application prête."
            echo "🔗 Images disponibles sur: ${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}"
          else
            echo "❌ PIPELINE ÉCHOUÉE - Vérifiez les logs ci-dessus"
            exit 1
          fi